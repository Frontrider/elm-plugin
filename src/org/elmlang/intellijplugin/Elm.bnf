{
  parserClass="org.elmlang.intellijplugin.parser.ElmParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Elm"
  psiImplClassSuffix="Impl"
  psiPackage="org.elmlang.intellijplugin.psi"
  psiImplPackage="org.elmlang.intellijplugin.psi.impl"

  parserUtilClass="org.elmlang.intellijplugin.manualParsing.ElmParserUtil"

  elementTypeHolderClass="org.elmlang.intellijplugin.psi.ElmTypes"
  elementTypeClass="org.elmlang.intellijplugin.psi.ElmElementType"
  tokenTypeClass="org.elmlang.intellijplugin.psi.ElmTokenType"

  tokens = [
    CASE_OF='CASE_OF'
    LET='LET'
    IN='IN'
    LET_IN='LET_IN'
  ]
}

// docs:
// https://github.com/JetBrains/Grammar-Kit
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md

elmFile ::= blank* [module_declaration] import_item* declaration_item*

private declaration_item ::= (declaration|blank)

private import_item ::= (import_clause|blank)

blank ::=
    WHITE_SPACE
    | INDENTATION
    | FRESH_LINE
    | comment

module_declaration ::= MODULE list_of_upper_cases [exposed_values] WHERE

list_of_upper_cases ::= UPPER_CASE_IDENTIFIER (DOT_IN_PATH UPPER_CASE_PATH)*

exposed_values ::= LEFT_PARENTHESIS (DOUBLE_DOT | list_of_values) RIGHT_PARENTHESIS

list_of_values ::= <<non_empty_list exposed_value>>

exposed_value ::=
    LOWER_CASE_IDENTIFIER
    | (UPPER_CASE_IDENTIFIER[exposed_union_constructors])

exposed_union_constructors ::= LEFT_PARENTHESIS (DOUBLE_DOT | list_of_union_constructors) RIGHT_PARENTHESIS

list_of_union_constructors ::= <<non_empty_list upper_case_identifier_parser>>

import_clause ::= IMPORT list_of_upper_cases [as_clause] [exposing_clause]

as_clause ::= AS UPPER_CASE_IDENTIFIER

exposing_clause ::= EXPOSING exposed_values

comment ::=
    LINE_COMMENT
    | level_comment

level_comment ::= START_COMMENT COMMENT_CONTENT* END_COMMENT

declaration ::=
    value_declaration
    | type_alias_declaration
    | type_declaration
    | type_annotation
{
    pin = 1
    recoverWhile = declaration_recover
}

value_declaration ::= value_declaration_left EQ expression SEPARATION_BY_INDENTATION*

type_alias_declaration ::= TYPE ALIAS UPPER_CASE_IDENTIFIER (LOWER_CASE_IDENTIFIER)* EQ type_reference

type_declaration ::= TYPE UPPER_CASE_IDENTIFIER (LOWER_CASE_IDENTIFIER)* EQ union_member (PIPE union_member)*

type_annotation ::= (LOWER_CASE_IDENTIFIER | operator_as_function) COLON type_reference

union_member ::= UPPER_CASE_IDENTIFIER single_type_reference*

type_reference ::= single_type_reference (ARROW single_type_reference)*

single_type_reference ::=
    list_of_upper_cases single_type_reference*
    | LOWER_CASE_IDENTIFIER
    | record_type
    | LEFT_PARENTHESIS type_reference RIGHT_PARENTHESIS

record_type ::= LEFT_BRACE [[record_base] <<non_empty_list field_type>>] RIGHT_BRACE

field_type ::= LOWER_CASE_IDENTIFIER COLON type_reference

inner_value_declaration ::= value_declaration_left EQ expression

value_declaration_left ::=
    LOWER_CASE_IDENTIFIER pattern+
    | operator_as_function pattern pattern
    | pattern

expression ::= list_of_operands (some_operator list_of_operands)*

list_of_operands ::= operand+

private some_operator ::=
    OPERATOR
    | LIST_CONSTRUCTOR

operand ::=
    literal
    | referenced_value
    | DOT LOWER_CASE_PATH
    | operator_as_function
    | LEFT_PARENTHESIS expression RIGHT_PARENTHESIS
    | tuple_constructor
    | tuple
    | list
    | record
    | if_else
    | case_of
    | let_in
    | anonymous_function

literal ::=
    STRING_LITERAL
    | NUMBER_LITERAL
    | CHAR_LITERAL

referenced_value ::=
    list_of_upper_cases (DOT_IN_PATH LOWER_CASE_PATH)*
    | LOWER_CASE_IDENTIFIER (DOT_IN_PATH LOWER_CASE_PATH)*

operator_as_function ::= LEFT_PARENTHESIS some_operator RIGHT_PARENTHESIS

tuple_constructor ::= LEFT_PARENTHESIS COMMA+ RIGHT_PARENTHESIS

tuple ::=
    LEFT_PARENTHESIS RIGHT_PARENTHESIS
    | LEFT_PARENTHESIS expression (COMMA expression)+ RIGHT_PARENTHESIS

list ::= LEFT_SQUARE_BRACKET [<<non_empty_list expression>>] RIGHT_SQUARE_BRACKET

record ::= LEFT_BRACE [[record_base] <<non_empty_list field>>] RIGHT_BRACE

record_base ::= LOWER_CASE_IDENTIFIER PIPE

field ::= LOWER_CASE_IDENTIFIER EQ expression

if_else ::= IF expression THEN expression ELSE expression

external case_of ::= parseCaseOf case_of_header case_of_branch one_or_more_separations

case_of_header ::= CASE expression OF

case_of_branch ::= pattern ARROW expression

one_or_more_separations ::= SEPARATION_BY_INDENTATION+

external let_in ::= parseLetIn inner_value_declaration other_values_declarations expression

other_values_declarations ::= (one_or_more_separations inner_value_declaration)* SEPARATION_BY_INDENTATION*

single_pattern ::=
    UNDERSCORE
    | LOWER_CASE_IDENTIFIER
    | record_pattern
    | list_pattern
    | union_pattern
    | parenthesed_pattern

pattern ::= single_pattern (LIST_CONSTRUCTOR single_pattern)*

record_pattern ::= LEFT_BRACE <<non_empty_list lower_case_identifier_parser>> RIGHT_BRACE

list_pattern ::= LEFT_SQUARE_BRACKET [<<non_empty_list pattern>>] RIGHT_SQUARE_BRACKET

union_pattern ::= UPPER_CASE_IDENTIFIER pattern*

parenthesed_pattern ::= LEFT_PARENTHESIS pattern RIGHT_PARENTHESIS

anonymous_function ::= BACKSLASH pattern+ ARROW expression

declaration_recover ::= !(FRESH_LINE)

private meta non_empty_list ::= <<p>> (COMMA <<p>>)*

private lower_case_identifier_parser ::= LOWER_CASE_IDENTIFIER

private upper_case_identifier_parser ::= UPPER_CASE_IDENTIFIER