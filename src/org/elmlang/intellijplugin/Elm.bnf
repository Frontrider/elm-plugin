{
  parserClass="org.elmlang.intellijplugin.parser.ElmParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Elm"
  psiImplClassSuffix="Impl"
  psiPackage="org.elmlang.intellijplugin.psi"
  psiImplPackage="org.elmlang.intellijplugin.psi.impl"

  parserUtilClass="org.elmlang.intellijplugin.manualParsing.ElmParserUtil"

  elementTypeHolderClass="org.elmlang.intellijplugin.psi.ElmTypes"
  elementTypeClass="org.elmlang.intellijplugin.psi.ElmElementType"
  tokenTypeClass="org.elmlang.intellijplugin.psi.ElmTokenType"

  tokens = [
    CASE_OF='CASE_OF'
    CASE='CASE'
    OF='OF'
  ]
}

// docs:
// https://github.com/JetBrains/Grammar-Kit
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md

elmFile ::= blank* [module_declaration] import_item* declaration_item*

private declaration_item ::= (declaration|blank)

private import_item ::= (import_clause|blank)

blank ::=
    WHITE_SPACE
    | INDENTATION
    | FRESH_LINE
    | comment

// module

module_declaration ::= MODULE module_name [exposed_values] WHERE

module_name ::= UPPER_CASE_IDENTIFIER (DOT_IN_PATH UPPER_CASE_PATH)*

exposed_values ::= LEFT_PARENTHESIS (DOUBLE_DOT | list_of_values) RIGHT_PARENTHESIS

list_of_values ::= exposed_value (COMMA exposed_value)*

exposed_value ::=
    LOWER_CASE_IDENTIRIER
    | (UPPER_CASE_IDENTIFIER[exposed_union_constructors])

exposed_union_constructors ::= LEFT_PARENTHESIS (DOUBLE_DOT | list_of_union_constructors) RIGHT_PARENTHESIS

list_of_union_constructors ::= UPPER_CASE_IDENTIFIER (COMMA UPPER_CASE_IDENTIFIER)*

// imports

import_clause ::= IMPORT module_name [as_clause] [exposing_clause]

as_clause ::= AS UPPER_CASE_IDENTIFIER

exposing_clause ::= EXPOSING exposed_values

// comments

comment ::=
    LINE_COMMENT
    | level_comment

level_comment ::= START_COMMENT COMMENT_CONTENT* END_COMMENT

// declarations

declaration ::= value_declaration

value_declaration ::= value_declaration_left EQ expression { pin = 1 recoverWhile="declaration_recover" }

value_declaration_left ::= LOWER_CASE_IDENTIRIER+

expression ::= list_of_operands (some_operator list_of_operands)*

list_of_operands ::= operand+

private some_operator ::=
    OPERATOR
    | LIST_CONSTRUCTOR

operand ::=
    literal
    | referenced_value
    | DOT LOWER_CASE_PATH
    | LEFT_PARENTHESIS some_operator RIGHT_PARENTHESIS
    | LEFT_PARENTHESIS expression RIGHT_PARENTHESIS
    | tuple_constructor
    | tuple
    | list
    | record
    | if_else
    | case_of

literal ::=
    STRING_LITERAL
    | NUMBER_LITERAL
    | CHAR_LITERAL

referenced_value ::=
    module_name (DOT_IN_PATH LOWER_CASE_PATH)*
    | LOWER_CASE_IDENTIRIER (DOT_IN_PATH LOWER_CASE_PATH)*

tuple_constructor ::= LEFT_PARENTHESIS COMMA+ RIGHT_PARENTHESIS

tuple ::=
    LEFT_PARENTHESIS RIGHT_PARENTHESIS
    | LEFT_PARENTHESIS expression (COMMA expression)* RIGHT_PARENTHESIS

list ::=
    LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
    | LEFT_SQUARE_BRACKET expression (COMMA expression)* RIGHT_SQUARE_BRACKET

record ::= LEFT_BRACE [derived_record] field (COMMA field)* RIGHT_BRACE

derived_record ::= LOWER_CASE_IDENTIRIER PIPE

field ::= LOWER_CASE_IDENTIRIER EQ expression

if_else ::= IF expression THEN expression ELSE expression

external case_of ::= parse_case_of expression

declaration_recover ::= !(FRESH_LINE)